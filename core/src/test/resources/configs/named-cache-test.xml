<?xml version="1.0" encoding="UTF-8"?>
<infinispan xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:infinispan:config:4.0">

   <global>

      <asyncListenerExecutor factory="org.infinispan.executors.DefaultExecutorFactory">
         <property name="maxThreads" value="5"/>
         <property name="threadNamePrefix" value="AsyncListenerThread"/>
      </asyncListenerExecutor>

      <asyncTransportExecutor factory="org.infinispan.executors.DefaultExecutorFactory">
         <property name="maxThreads" value="25"/>
         <property name="threadNamePrefix" value="AsyncSerializationThread"/>
      </asyncTransportExecutor>

      <evictionScheduledExecutor factory="org.infinispan.executors.DefaultScheduledExecutorFactory">
         <property name="threadNamePrefix" value="EvictionThread"/>
      </evictionScheduledExecutor>

      <replicationQueueScheduledExecutor factory="org.infinispan.executors.DefaultScheduledExecutorFactory">
         <property name="threadNamePrefix" value="ReplicationQueueThread"/>
      </replicationQueueScheduledExecutor>

      <transport transportClass = "org.infinispan.remoting.transport.jgroups.JGroupsTransport" clusterName="infinispan-cluster" 
      		distributedSyncTimeout="50000">
         <!-- Note that the JGroups transport uses sensible defaults if no configuration property is defined. -->
         <property name="configurationFile" value="udp.xml"/>
         <!-- See the JGroupsTransport javadocs for more flags -->
      </transport>

      <serialization marshallerClass="org.infinispan.marshall.VersionAwareMarshaller" version="1.0"/>
      <globalJmxStatistics enabled="false" jmxDomain="funky_domain"
                           mBeanServerLookup="org.infinispan.jmx.PerThreadMBeanServerLookup"
                           allowDuplicateDomains="true"/>
                           
      <shutdown hookBehavior="REGISTER"/>                           
   </global>

   <default>
      <locking concurrencyLevel="100" lockAcquisitionTimeout="1000"/>
      <jmxStatistics enabled="false"/>
   </default>

   <namedCache name="transactional">
      <transaction transactionManagerLookupClass="org.infinispan.transaction.lookup.GenericTransactionManagerLookup" useEagerLocking="true"/>
   </namedCache>

   <namedCache name="syncRepl">
      <clustering mode="repl">
         <stateRetrieval fetchInMemoryState="false"/>
         <sync replTimeout="15000"/>
      </clustering>
   </namedCache>

   <namedCache name="asyncRepl">
      <clustering mode="repl">
         <stateRetrieval fetchInMemoryState="false"/>
         <async asyncMarshalling="false"/>
      </clustering>
   </namedCache>

   <namedCache name="asyncReplQueue">
      <clustering mode="repl">
         <stateRetrieval fetchInMemoryState="false"/>
         <async useReplQueue="true" replQueueInterval="1234" replQueueMaxElements="100"/>
      </clustering>
   </namedCache>

   <namedCache name="txSyncRepl">
      <transaction/>
      <clustering mode="repl">
         <stateRetrieval fetchInMemoryState="false"/>
         <sync replTimeout="15000"/>
      </clustering>
   </namedCache>

   <namedCache name="overriding">
      <locking isolationLevel="REPEATABLE_READ" concurrencyLevel="1000" lockAcquisitionTimeout="20000"/>
   </namedCache>

   <namedCache name="lazyDeserialization">
      <locking isolationLevel="REPEATABLE_READ" concurrencyLevel="1000" lockAcquisitionTimeout="20000"/>
      <lazyDeserialization enabled="true"/>
   </namedCache>

   <namedCache name="withLoader">
      <loaders passivation="false" shared="false" preload="true">

         <!--
            We can have multiple cache loaders, which get chained
         -->
         <loader class="org.infinispan.loaders.file.FileCacheStore" fetchPersistentState="true"
                 ignoreModifications="true" purgeOnStartup="true">

            <!-- See the documentation for more configuration examples and flags. -->
            <properties>
               <property name="location" value="/tmp/FileCacheStore-Location"/>
            </properties>
            <singletonStore enabled="true" pushStateWhenCoordinator="true" pushStateTimeout="20000"/>
            <async enabled="true" batchSize="1000" threadPoolSize="5"/>
         </loader>
      </loaders>
   </namedCache>

   <namedCache name="dist">
      <clustering mode="distribution">
         <sync/>
         <hash numOwners="3" rehashWait="120000"/>
         <l1 enabled="true" lifespan="600000"/>
      </clustering>
   </namedCache>

   <namedCache name="withouthJmxEnabled">
      <clustering>
         <async useReplQueue="true" replQueueInterval="100" replQueueMaxElements="200"/>
      </clustering>
      <jmxStatistics enabled="false"/>
   </namedCache>
   
   
   <namedCache name="cacheWithCustomInterceptors">
   
      <!--
      Define custom interceptors.  All custom interceptors need to extend org.jboss.cache.interceptors.base.CommandInterceptor
      Here we use existing class so we can actually load it
      -->   
      <customInterceptors>
         <interceptor position="first" class="org.infinispan.interceptors.CallInterceptor"></interceptor>
         <interceptor position="last" class="org.infinispan.interceptors.CallInterceptor"/>
         <interceptor index="3" class="org.infinispan.interceptors.CallInterceptor"/>
         <interceptor before="org.infinispan.interceptors.CallInterceptor" class="org.infinispan.interceptors.CallInterceptor"/>
         <interceptor after="org.infinispan.interceptors.CallInterceptor" class="org.infinispan.interceptors.CallInterceptor"/>
      </customInterceptors>
   </namedCache>

</infinispan>
